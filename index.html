/**
 * DOM要素から一意で安定したCSSセレクタを生成する
 * 優先順位: ID > 一意のクラス > タグ+クラス > nth-of-typeパス
 * @param {HTMLElement} el - 対象のDOM要素
 * @param {Document} doc - 要素が存在するドキュメント (iframeのdocument)
 * @returns {string} 生成されたCSSセレクタ
 */
export const getUniqueCssSelector = (el, doc) => {
  if (!(el instanceof HTMLElement)) return '';

  // 1. IDセレクタ (最も優先)
  if (el.id) {
    const selector = `#${el.id}`;
    if (doc.querySelectorAll(selector).length === 1) {
      return selector;
    }
  }

  // 2. クラスセレクタ (一意なものがあれば優先)
  if (el.classList.length > 0) {
    for (const className of el.classList) {
      const selector = `.${className}`;
      if (doc.querySelectorAll(selector).length === 1) {
        return `${el.tagName.toLowerCase()}${selector}`;
      }
    }
  }

  // 3. フルパスを生成 (フォールバック)
  const path = [];
  let current = el;
  while (current && current.parentElement) {
    let selectorPart = current.tagName.toLowerCase();
    
    // 同一タグの兄弟要素の中での位置を特定 (nth-of-type)
    let sibling = current;
    let nth = 1;
    while (sibling.previousElementSibling) {
      sibling = sibling.previousElementSibling;
      if (sibling.tagName === current.tagName) {
        nth++;
      }
    }
    
    // 兄弟要素に同じタグがなければ、:nth-of-typeは不要
    const nextSibling = current.nextElementSibling;
    let hasSimilarSibling = false;
    if (nextSibling) {
        let tempSibling = current.parentElement.firstElementChild;
        while(tempSibling) {
            if(tempSibling.tagName === current.tagName && tempSibling !== current) {
                hasSimilarSibling = true;
                break;
            }
            tempSibling = tempSibling.nextElementSibling;
        }
    }

    if (nth > 1 || hasSimilarSibling) {
      selectorPart += `:nth-of-type(${nth})`;
    }

    path.unshift(selectorPart);
    
    // bodyまで来たら終了
    if (current.parentElement.tagName === 'BODY') break;
    current = current.parentElement;
  }

  return path.join(' > ');
};
