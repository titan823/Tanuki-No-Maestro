    let action = null;
    let dragOffX=0, dragOffY=0;
    let resizeEdge = null;
    let startRect = null;
    let scaleState = null;
    let rotateState = null;
    const isTouchEnv = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

    function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }
    function angle(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax); }
    function canvasXYFromClient(clientX, clientY) {
        const rect = stage.getBoundingClientRect();
        return { mx: clientX - rect.left, my: clientY - rect.top };
    }

    function handlePointerDown(mx, my) {
        const l = layers.find(x => x.id===selectedId);
        if (!l || !l.visible) return;

        const handleRadius = isTouchEnv ? 22 : 12;
        const buttonRadius = isTouchEnv ? 24 : 16;

        const cxh = l.x + l.w/2, cyh = l.y + l.h/2;
        const rad = (Number(l.rot)||0) * Math.PI/180;
        function rotp(dx,dy){ return { x: cxh + (dx*Math.cos(rad) - dy*Math.sin(rad)), y: cyh + (dx*Math.sin(rad) + dy*Math.cos(rad)) }; }
        const near = (ax,ay,bx,by,r) => Math.hypot(ax-bx, ay-by) <= r;

        const pFlip = rotp(-l.w/2 + 10, -l.h/2 + 10);
        if (near(mx, my, pFlip.x, pFlip.y, buttonRadius)){ l.flipX = !l.flipX; return; }
        
        const pReset = rotp(l.w/2 - 10, -l.h/2 + 10);
        if (near(mx, my, pReset.x, pReset.y, buttonRadius)){
            const baseW = l.origW || l.w, baseH = l.origH || l.h;
            const r = baseW / baseH;
            const candA = { w: Math.max(1, Math.round(l.h * r)), h: l.h };
            const candB = { w: l.w, h: Math.max(1, Math.round(l.w / r)) };
            const best = (Math.abs(candA.w - l.w) <= Math.abs(candB.h - l.h)) ? candA : candB;
            l.w = best.w; l.h = best.h;
            l.x = Math.round(cxh - l.w/2); l.y = Math.round(cyh - l.h/2);
            return;
        }

        const topMid = rotp(0, -l.h/2), bottomMid = rotp(0,  l.h/2), leftMid = rotp(-l.w/2, 0), rightMid = rotp( l.w/2, 0);
        if (near(mx, my, topMid.x, topMid.y, handleRadius)){ action='resize-edge'; resizeEdge='top'; }
        else if (near(mx, my, bottomMid.x, bottomMid.y, handleRadius)){ action='resize-edge'; resizeEdge='bottom'; }
        else if (near(mx, my, leftMid.x, leftMid.y, handleRadius)){ action='resize-edge'; resizeEdge='left'; }
        else if (near(mx, my, rightMid.x, rightMid.y, handleRadius)){ action='resize-edge'; resizeEdge='right'; }

        if (action === 'resize-edge') {
            startRect={ x:l.x, y:l.y, w:l.w, h:l.h }; stage.classList.add('dragging'); return;
        }
        
        const pBL = rotp(-l.w/2, l.h/2);
        const pBR = rotp(l.w/2, l.h/2);
        if (near(mx, my, pBR.x, pBR.y, handleRadius)) {
            action = 'scale';
            scaleState = { cx:cxh, cy:cyh, startW: l.w, startH: l.h, startDist: Math.max(1, dist(cxh,cyh,mx,my)) };
            stage.classList.add('dragging'); return;
        }
        if (near(mx, my, pBL.x, pBL.y, handleRadius)) {
            action = 'rotate';
            rotateState = { cx:cxh, cy:cyh, startAngle: angle(cxh,cyh,mx,my), startRot: Number(l.rot)||0 };
            stage.classList.add('dragging'); return;
        }

        const mxg = mx - cxh; const myg = my - cyh;
        const lx = mxg * Math.cos(-rad) - myg * Math.sin(-rad);
        const ly = mxg * Math.sin(-rad) + myg * Math.cos(-rad);
        if (Math.abs(lx) < l.w / 2 && Math.abs(ly) < l.h / 2) {
            action = 'move'; stage.classList.add('dragging');
            dragOffX = mx - l.x; dragOffY = my - l.y;
        }
    }
    
    function handlePointerMove(mx, my, useShiftKey) {
        if (!action) { return; }
        const l = layers.find(x => x.id===selectedId);
        if (!l) return;

        if (action === 'move') {
            let nx = Math.round(mx - dragOffX); let ny = Math.round(my - dragOffY);
            const s = snapRect(nx, ny, l.w, l.h, l);
            l.x = s.x; l.y = s.y;
        } else if (action === 'resize-edge' && startRect) {
            const ox=startRect.x, oy=startRect.y, ow=startRect.w, oh=startRect.h;
            const rad = (Number(l.rot)||0) * Math.PI/180;
            const mxg=mx-(ox+ow/2), myg=my-(oy+oh/2);
            const lx = mxg * Math.cos(-rad) - myg * Math.sin(-rad);
            const ly = mxg * Math.sin(-rad) + myg * Math.cos(-rad);
            let newW = ow, newH = oh, dx = 0, dy = 0;
            if (resizeEdge === 'left') { const newLeftEdge = Math.min(lx, ow/2-1); newW = ow/2 - newLeftEdge; dx = (newLeftEdge + ow/2) / 2; }
            else if (resizeEdge === 'right') { const newRightEdge = Math.max(lx, -ow/2+1); newW = newRightEdge + ow/2; dx = (newRightEdge - ow/2) / 2; }
            else if (resizeEdge === 'top') { const newTopEdge = Math.min(ly, oh/2-1); newH = oh/2 - newTopEdge; dy = (newTopEdge + oh/2) / 2; }
            else if (resizeEdge === 'bottom') { const newBottomEdge = Math.max(ly, -oh/2+1); newH = newBottomEdge + oh/2; dy = (newBottomEdge - oh/2) / 2; }
            const worldDX = dx * Math.cos(rad) - dy * Math.sin(rad);
            const worldDY = dx * Math.sin(rad) + dy * Math.cos(rad);
            l.x = Math.round(ox + ow/2 - newW/2 + worldDX);
            l.y = Math.round(oy + oh/2 - newH/2 + worldDY);
            l.w = Math.max(1, Math.round(newW));
            l.h = Math.max(1, Math.round(newH));
        } else if (action === 'scale' && scaleState) {
            const { cx, cy, startW, startH, startDist } = scaleState;
            const curDist = Math.max(1, dist(cx,cy,mx,my));
            const sc = Math.max(0.01, curDist / startDist);
            l.w = Math.max(1, Math.round(startW * sc));
            l.h = Math.max(1, Math.round(startH * sc));
            l.x = Math.round(cx - l.w/2);
            l.y = Math.round(cy - l.h/2);
        } else if (action === 'rotate' && rotateState) {
            const { cx, cy, startAngle, startRot } = rotateState;
            const ang = angle(cx,cy,mx,my);
            let deltaDeg = (ang - startAngle) * 180 / Math.PI;
            if (useShiftKey) { deltaDeg = Math.round(deltaDeg/15)*15; }
            l.rot = (startRot + deltaDeg);
        }
    }
    
    function handlePointerUp() {
        action=null; resizeEdge=null; startRect=null; scaleState=null; rotateState=null;
        stage.classList.remove('dragging');
    }

    stage.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const { mx, my } = canvasXYFromClient(e.clientX, e.clientY);
        handlePointerDown(mx, my);
        e.preventDefault();
    });
    window.addEventListener('mousemove', (e) => {
        if (e.buttons === 0) {
          if (action) handlePointerUp();
          return;
        }
        const { mx, my } = canvasXYFromClient(e.clientX, e.clientY);
        handlePointerMove(mx, my, e.shiftKey);
    });
    window.addEventListener('mouseup', (e) => {
        if (e.button !== 0) return;
        handlePointerUp();
    });

    stage.addEventListener('touchstart', (e) => {
        const t = e.changedTouches[0];
        const { mx, my } = canvasXYFromClient(t.clientX, t.clientY);
        handlePointerDown(mx, my);
        e.preventDefault();
    }, { passive: false });
    window.addEventListener('touchmove', (e) => {
        const t = e.changedTouches[0];
        const { mx, my } = canvasXYFromClient(t.clientX, t.clientY);
        handlePointerMove(mx, my, false);
        e.preventDefault();
    }, { passive: false });
    window.addEventListener('touchend', handlePointerUp);
    window.addEventListener('touchcancel', handlePointerUp);

    stage.addEventListener('contextmenu', (e) => e.preventDefault());
